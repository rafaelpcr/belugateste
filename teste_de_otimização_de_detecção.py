# -*- coding: utf-8 -*-
"""Teste de otimiza√ß√£o de detec√ß√£o

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h7tsHlJsRYrc85LYPs7nSHWpzJpGRAE3
"""

import mysql.connector
from datetime import datetime, timedelta
import logging
import json
from flask import Flask, request, jsonify
import os
from dotenv import load_dotenv
import traceback
import time
import numpy as np
import uuid

# Configura√ß√£o b√°sica de logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('radar.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('radar_app')

# Carregar vari√°veis de ambiente
load_dotenv()

app = Flask(__name__)

def convert_radar_data(raw_data):
    """Converte dados do radar para o formato do banco"""
    try:
        logger.debug(f"Convertendo dados brutos: {raw_data}")

        # Constantes para valida√ß√£o
        HEART_RATE_MIN = 60
        HEART_RATE_MAX = 100
        BREATH_RATE_MIN = 12
        BREATH_RATE_MAX = 20
        MOVE_SPEED_MIN = 0
        MOVE_SPEED_MAX = 100  # Reduzido para 1 m/s
        COORD_MIN = -2  # -2 metros
        COORD_MAX = 2   # 2 metros
        HEART_BREATH_RATIO_MIN = 3.0
        HEART_BREATH_RATIO_MAX = 5.0

        # Processar e validar coordenadas
        try:
            x_point = float(raw_data.get('x_point', raw_data.get('x', 0)))
            y_point = float(raw_data.get('y_point', raw_data.get('y', 0)))

            # Validar e normalizar coordenadas
            if abs(x_point) > COORD_MAX or abs(y_point) > COORD_MAX:
                logger.warning(f"Coordenadas fora dos limites: ({x_point}, {y_point})")
                x_point = max(min(x_point, COORD_MAX), COORD_MIN)
                y_point = max(min(y_point, COORD_MAX), COORD_MIN)

            # Arredondar para 2 casas decimais
            x_point = round(x_point, 2)
            y_point = round(y_point, 2)

        except (ValueError, TypeError) as e:
            logger.error(f"Erro ao converter coordenadas: {str(e)}")
            x_point = 0
            y_point = 0

        # Processar e validar move_speed
        try:
            move_speed = float(raw_data.get('move_speed', 0))

            # Validar faixa de valores
            if move_speed < MOVE_SPEED_MIN:
                logger.warning(f"Move speed negativo detectado: {move_speed}, ajustando para 0")
                move_speed = 0
            elif move_speed > MOVE_SPEED_MAX:
                logger.warning(f"Move speed muito alto detectado: {move_speed}, ajustando para m√°ximo")
                move_speed = MOVE_SPEED_MAX

            # Aplicar suaviza√ß√£o para valores muito baixos e arredondar
            if 0 < move_speed < 5:
                move_speed = 5
                logger.info("Move speed muito baixo, ajustando para velocidade m√≠nima")

            # Arredondar para n√∫mero inteiro
            move_speed = round(move_speed)

        except (ValueError, TypeError) as e:
            logger.error(f"Erro ao converter move_speed: {str(e)}")
            move_speed = 0

        # Processar e validar heart_rate
        try:
            heart_rate = float(raw_data.get('heart_rate', 0))

            # Validar valores absurdos
            if heart_rate > 300 or heart_rate < 0:
                logger.warning(f"Heart rate inv√°lido: {heart_rate}, descartando")
                heart_rate = None
            # Validar faixa normal
            elif not (HEART_RATE_MIN <= heart_rate <= HEART_RATE_MAX):
                logger.warning(f"Heart rate fora da faixa aceit√°vel: {heart_rate} bpm")
                if heart_rate < HEART_RATE_MIN:
                    heart_rate = HEART_RATE_MIN
                elif heart_rate > HEART_RATE_MAX:
                    heart_rate = HEART_RATE_MAX

            # Arredondar para n√∫mero inteiro
            if heart_rate is not None:
                heart_rate = round(heart_rate)

        except (ValueError, TypeError) as e:
            logger.error(f"Erro ao converter heart_rate: {str(e)}")
            heart_rate = None

        # Processar e validar breath_rate
        try:
            breath_rate = float(raw_data.get('breath_rate', 0))

            # Validar valores absurdos
            if breath_rate > 60 or breath_rate < 0:
                logger.warning(f"Breath rate inv√°lido: {breath_rate}, descartando")
                breath_rate = None
            # Validar faixa normal
            elif not (BREATH_RATE_MIN <= breath_rate <= BREATH_RATE_MAX):
                logger.warning(f"Breath rate fora da faixa aceit√°vel: {breath_rate} rpm")
                if breath_rate < BREATH_RATE_MIN:
                    breath_rate = BREATH_RATE_MIN
                elif breath_rate > BREATH_RATE_MAX:
                    breath_rate = BREATH_RATE_MAX

            # Arredondar para n√∫mero inteiro
            if breath_rate is not None:
                breath_rate = round(breath_rate)

        except (ValueError, TypeError) as e:
            logger.error(f"Erro ao converter breath_rate: {str(e)}")
            breath_rate = None

        # Validar consist√™ncia entre heart_rate e breath_rate
        if heart_rate is not None and breath_rate is not None and breath_rate > 0:
            ratio = heart_rate / breath_rate
            if not (HEART_BREATH_RATIO_MIN <= ratio <= HEART_BREATH_RATIO_MAX):
                logger.warning(f"Raz√£o heart_rate/breath_rate inconsistente: {ratio:.2f}")
                # Se a raz√£o estiver muito fora, descartar ambos os valores
                heart_rate = None
                breath_rate = None

        # Montar dados convertidos
        converted_data = {
            'device_id': 'RADAR_1',
            'x_point': x_point,
            'y_point': y_point,
            'move_speed': move_speed,
            'heart_rate': heart_rate,
            'breath_rate': breath_rate,
            'serial_number': raw_data.get('serial_number', 'RADAR_1')
        }

        # Log detalhado dos dados processados
        logger.info(f"‚úÖ Dados convertidos com sucesso:")
        logger.info(f"  - Posi√ß√£o: ({x_point}, {y_point})")
        logger.info(f"  - Velocidade: {move_speed} cm/s")
        logger.info(f"  - Heart Rate: {heart_rate} bpm")
        logger.info(f"  - Breath Rate: {breath_rate} rpm")
        logger.info(f"  - Serial Number: {converted_data['serial_number']}")

        return converted_data, None

    except Exception as e:
        logger.error(f"‚ùå Erro ao converter dados: {str(e)}")
        logger.error(f"Stack trace: {traceback.format_exc()}")
        return None, f"Erro ao converter dados: {str(e)}"

class ShelfManager:
    def __init__(self):
        # Constantes para mapeamento de se√ß√µes
        self.SECTION_WIDTH = 0.5  # Largura de cada se√ß√£o em metros
        self.SECTION_HEIGHT = 0.3  # Altura de cada se√ß√£o em metros
        self.MAX_SECTIONS_X = 4    # N√∫mero m√°ximo de se√ß√µes na horizontal
        self.MAX_SECTIONS_Y = 3    # N√∫mero m√°ximo de se√ß√µes na vertical

    def initialize_database(self, db_manager):
        """Inicializa a tabela de se√ß√µes da g√¥ndola"""
        try:
            # Criar tabela para se√ß√µes da g√¥ndola
            db_manager.cursor.execute("""
                CREATE TABLE IF NOT EXISTS shelf_sections (
                    id INT AUTO_INCREMENT PRIMARY KEY,
                    section_name VARCHAR(50),
                    x_start FLOAT,
                    y_start FLOAT,
                    x_end FLOAT,
                    y_end FLOAT,
                    product_id VARCHAR(50),
                    product_name VARCHAR(100),
                    last_updated DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    is_active BOOLEAN DEFAULT TRUE
                )
            """)
            db_manager.conn.commit()
            logger.info("‚úÖ Tabela shelf_sections criada/verificada com sucesso!")

        except Exception as e:
            logger.error(f"‚ùå Erro ao inicializar tabela shelf_sections: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    def get_section_at_position(self, x, y, db_manager):
        """
        Identifica a se√ß√£o da g√¥ndola baseado nas coordenadas (x, y)
        Retorna: (section_id, section_name, product_id, product_name) ou None se n√£o encontrar
        """
        try:
            # Buscar se√ß√µes ativas que contenham o ponto (x, y)
            query = """
                SELECT id, section_name, product_id, product_name
                FROM shelf_sections
                WHERE is_active = TRUE
                AND x_start <= %s AND x_end >= %s
                AND y_start <= %s AND y_end >= %s
                LIMIT 1
            """

            db_manager.cursor.execute(query, (x, x, y, y))
            section = db_manager.cursor.fetchone()

            if section:
                logger.info(f"Se√ß√£o encontrada: {section['section_name']} (Produto: {section['product_name']})")
                return section
            else:
                logger.info(f"Nenhuma se√ß√£o encontrada para as coordenadas (x={x}, y={y})")
                return None

        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar se√ß√£o: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    def add_section(self, section_data, db_manager):
        """
        Adiciona uma nova se√ß√£o √† g√¥ndola
        section_data: dict com section_name, x_start, y_start, x_end, y_end, product_id, product_name
        """
        try:
            query = """
                INSERT INTO shelf_sections
                (section_name, x_start, y_start, x_end, y_end, product_id, product_name)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """

            params = (
                section_data['section_name'],
                section_data['x_start'],
                section_data['y_start'],
                section_data['x_end'],
                section_data['y_end'],
                section_data['product_id'],
                section_data['product_name']
            )

            db_manager.cursor.execute(query, params)
            db_manager.conn.commit()

            logger.info(f"‚úÖ Se√ß√£o {section_data['section_name']} adicionada com sucesso!")
            return True

        except Exception as e:
            logger.error(f"‚ùå Erro ao adicionar se√ß√£o: {str(e)}")
            logger.error(traceback.format_exc())
            return False

    def update_section(self, section_id, section_data, db_manager):
        """
        Atualiza uma se√ß√£o existente
        section_data: dict com os campos a serem atualizados
        """
        try:
            # Construir query dinamicamente baseado nos campos fornecidos
            update_fields = []
            params = []

            for field, value in section_data.items():
                if field in ['section_name', 'x_start', 'y_start', 'x_end', 'y_end',
                           'product_id', 'product_name', 'is_active']:
                    update_fields.append(f"{field} = %s")
                    params.append(value)

            if not update_fields:
                logger.warning("Nenhum campo para atualizar")
                return False

            # Adicionar section_id aos par√¢metros
            params.append(section_id)

            query = f"""
                UPDATE shelf_sections
                SET {', '.join(update_fields)}
                WHERE id = %s
            """

            db_manager.cursor.execute(query, params)
            db_manager.conn.commit()

            logger.info(f"‚úÖ Se√ß√£o {section_id} atualizada com sucesso!")
            return True

        except Exception as e:
            logger.error(f"‚ùå Erro ao atualizar se√ß√£o: {str(e)}")
            logger.error(traceback.format_exc())
            return False

    def get_all_sections(self, db_manager):
        """Retorna todas as se√ß√µes ativas"""
        try:
            query = """
                SELECT * FROM shelf_sections
                WHERE is_active = TRUE
                ORDER BY section_name
            """

            db_manager.cursor.execute(query)
            sections = db_manager.cursor.fetchall()

            return sections

        except Exception as e:
            logger.error(f"‚ùå Erro ao buscar se√ß√µes: {str(e)}")
            logger.error(traceback.format_exc())
            return []

# Inst√¢ncia global do gerenciador de se√ß√µes
shelf_manager = ShelfManager()

class DatabaseManager:
    def __init__(self):
        self.conn = None
        self.cursor = None
        self.last_sequence = 0
        self.last_move_speed = None
        self.connect_with_retry()

    def connect_with_retry(self, max_attempts=5):
        """Tenta conectar ao banco com retry"""
        attempt = 0
        while attempt < max_attempts:
            try:
                attempt += 1
                logger.info(f"Tentativa {attempt} de {max_attempts} para conectar ao banco...")

                if self.conn:
                    try:
                        self.conn.close()
                    except:
                        pass

                # Usando driver puro Python e configura√ß√µes SSL mais simples
                db_config = {
                    "host": os.getenv("DB_HOST", "168.75.89.11"),
                    "user": os.getenv("DB_USER", "belugaDB"),
                    "password": os.getenv("DB_PASSWORD", "Rpcr@300476"),
                    "database": os.getenv("DB_NAME", "Beluga_Analytics"),
                    "port": int(os.getenv("DB_PORT", 3306)),
                    "use_pure": True,
                    "ssl_disabled": True,
                    "auth_plugin": "mysql_native_password",
                    "connect_timeout": 120,
                    "pool_size": 3,
                    "charset": "utf8mb4",
                    "collation": "utf8mb4_unicode_ci"
                }
                self.conn = mysql.connector.connect(**db_config)
                self.cursor = self.conn.cursor(dictionary=True)

                # Testar conex√£o
                self.cursor.execute("SELECT 1")
                self.cursor.fetchone()

                logger.info("‚úÖ Conex√£o estabelecida com sucesso!")
                self.initialize_database()
                return True

            except Exception as e:
                logger.error(f"‚ùå Tentativa {attempt} falhou: {str(e)}")
                if attempt == max_attempts:
                    logger.error("Todas as tentativas de conex√£o falharam!")
                    raise
                time.sleep(2)
        return False

    def initialize_database(self):
        """Inicializa o banco de dados"""
        try:
            # Verificar/criar tabela de dispositivos primeiro
            logger.info("Verificando tabela de dispositivos...")
            self.cursor.execute("""
                CREATE TABLE IF NOT EXISTS Dispositivos (
                    serial_number VARCHAR(50) PRIMARY KEY,
                    nome VARCHAR(100),
                    tipo VARCHAR(50),
                    status VARCHAR(20) DEFAULT 'ATIVO',
                    data_cadastro DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            """)

            # Inserir dispositivo padr√£o se n√£o existir
            logger.info("Verificando dispositivo padr√£o...")
            self.cursor.execute("""
                INSERT IGNORE INTO Dispositivos (serial_number, nome, tipo)
                VALUES ('RADAR_1', 'Radar Principal', 'RADAR')
            """)

            # Verificar se a tabela radar_dados existe
            self.cursor.execute("SHOW TABLES LIKE 'radar_dados'")
            table_exists = self.cursor.fetchone()

            if not table_exists:
                # Criar tabela se n√£o existir
                logger.info("Criando tabela radar_dados...")
                self.cursor.execute("""
                    CREATE TABLE radar_dados (
                        id INT AUTO_INCREMENT PRIMARY KEY,
                        x_point FLOAT,
                        y_point FLOAT,
                        move_speed FLOAT,
                        heart_rate FLOAT,
                        breath_rate FLOAT,
                        satisfaction_score FLOAT,
                        satisfaction_class VARCHAR(20),
                        is_engaged BOOLEAN,
                        engagement_duration INT,
                        session_id VARCHAR(36),
                        section_id INT,
                        product_id VARCHAR(50),
                        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                        serial_number VARCHAR(50),
                        FOREIGN KEY (serial_number) REFERENCES Dispositivos(serial_number)
                    )
                """)
                logger.info("Tabela radar_dados criada com sucesso!")

            # Verificar se a coluna serial_number existe
            self.cursor.execute("SHOW COLUMNS FROM radar_dados LIKE 'serial_number'")
            serial_number_exists = self.cursor.fetchone()

            if not serial_number_exists:
                logger.info("Adicionando coluna serial_number...")
                try:
                    # Adicionar coluna com valor padr√£o
                    self.cursor.execute("""
                        ALTER TABLE radar_dados
                        ADD COLUMN serial_number VARCHAR(50),
                        ADD FOREIGN KEY (serial_number) REFERENCES Dispositivos(serial_number)
                    """)
                    # Atualizar registros existentes
                    self.cursor.execute("""
                        UPDATE radar_dados
                        SET serial_number = 'RADAR_1'
                        WHERE serial_number IS NULL
                    """)
                    logger.info("Coluna serial_number adicionada e atualizada com sucesso!")
                except Exception as e:
                    logger.error(f"Erro ao adicionar coluna serial_number: {str(e)}")

            # Verificar e adicionar outras colunas que est√£o faltando
            logger.info("Verificando outras colunas da tabela radar_dados...")

            # Verificar se as colunas existem
            self.cursor.execute("DESCRIBE radar_dados")
            columns = self.cursor.fetchall()
            existing_columns = [column['Field'] for column in columns]

            logger.info(f"Colunas existentes: {existing_columns}")

            # Colunas que devem existir
            required_columns = {
                'satisfaction_score': 'ADD COLUMN satisfaction_score FLOAT',
                'satisfaction_class': 'ADD COLUMN satisfaction_class VARCHAR(20)',
                'is_engaged': 'ADD COLUMN is_engaged BOOLEAN',
                'engagement_duration': 'ADD COLUMN engagement_duration INT',
                'session_id': 'ADD COLUMN session_id VARCHAR(36)',
                'section_id': 'ADD COLUMN section_id INT',
                'product_id': 'ADD COLUMN product_id VARCHAR(50)'
            }

            # Adicionar colunas faltantes
            for column, add_command in required_columns.items():
                if column not in existing_columns:
                    logger.info(f"Adicionando coluna {column}...")
                    try:
                        self.cursor.execute(f"ALTER TABLE radar_dados {add_command}")
                        logger.info(f"Coluna {column} adicionada com sucesso!")
                    except Exception as e:
                        logger.error(f"Erro ao adicionar coluna {column}: {str(e)}")

            self.conn.commit()
            logger.info("‚úÖ Banco de dados atualizado com sucesso!")

        except Exception as e:
            logger.error(f"‚ùå Erro ao inicializar banco: {str(e)}")
            logger.error(traceback.format_exc())
            raise

    def ensure_device_exists(self, serial_number, nome=None, tipo=None):
        """Garante que o dispositivo existe no banco"""
        try:
            # Verificar se o dispositivo j√° existe
            self.cursor.execute("""
                SELECT serial_number FROM Dispositivos
                WHERE serial_number = %s
            """, (serial_number,))

            device = self.cursor.fetchone()

            if not device:
                # Inserir novo dispositivo
                logger.info(f"Inserindo novo dispositivo: {serial_number}")
                self.cursor.execute("""
                    INSERT INTO Dispositivos (serial_number, nome, tipo)
                    VALUES (%s, %s, %s)
                """, (
                    serial_number,
                    nome or f"Radar {serial_number}",
                    tipo or "RADAR"
                ))
                self.conn.commit()
                logger.info(f"‚úÖ Dispositivo {serial_number} inserido com sucesso!")

            return True
        except Exception as e:
            logger.error(f"‚ùå Erro ao verificar/inserir dispositivo: {str(e)}")
            return False

    def insert_data(self, data, analytics_data=None):
        """Insere dados no banco"""
        try:
            logger.info("="*50)
            logger.info("Iniciando inser√ß√£o de dados no banco...")

            # Verificar conex√£o antes de inserir
            if not self.conn or not self.conn.is_connected():
                logger.info("Conex√£o n√£o dispon√≠vel, tentando reconectar...")
                self.connect_with_retry()

            # Garantir que o dispositivo existe
            serial_number = data.get('serial_number', 'RADAR_1')
            if not self.ensure_device_exists(serial_number):
                return False

            # Valores padr√£o para analytics
            satisfaction_score = None
            satisfaction_class = None
            is_engaged = False
            engagement_duration = 0

            # Extrair dados de analytics se dispon√≠veis
            if analytics_data:
                if 'satisfaction' in analytics_data:
                    satisfaction_score = analytics_data['satisfaction'].get('score')
                    satisfaction_class = analytics_data['satisfaction'].get('classification')
                is_engaged = bool(analytics_data.get('engaged', False))
                engagement_duration = int(analytics_data.get('engagement_duration', 0))

            # Verificar se o dado tem o campo is_engaged (prioridade sobre analytics)
            if 'is_engaged' in data and data['is_engaged'] is not None:
                is_engaged = bool(data['is_engaged'])
                logger.info(f"Campo is_engaged encontrado nos dados: {is_engaged}")

            # Preparar query com campos adicionais
            query = """
                INSERT INTO radar_dados
                (x_point, y_point, move_speed, heart_rate, breath_rate,
                 satisfaction_score, satisfaction_class, is_engaged, engagement_duration,
                 session_id, section_id, product_id, serial_number)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """

            # Preparar par√¢metros
            params = (
                float(data.get('x_point', 0)),
                float(data.get('y_point', 0)),
                float(data.get('move_speed', 0)),
                float(data.get('heart_rate', 0)) if data.get('heart_rate') is not None else None,
                float(data.get('breath_rate', 0)) if data.get('breath_rate') is not None else None,
                float(satisfaction_score) if satisfaction_score is not None else None,
                satisfaction_class,
                is_engaged,
                engagement_duration,
                data.get('session_id'),
                data.get('section_id'),
                data.get('product_id'),
                serial_number
            )

            logger.info(f"Query SQL: {query}")
            logger.info(f"Par√¢metros: {params}")

            # Executar inser√ß√£o
            self.cursor.execute(query, params)
            self.conn.commit()

            logger.info("‚úÖ Dados inseridos com sucesso!")
            logger.info("="*50)
            return True

        except Exception as e:
            logger.error("="*50)
            logger.error(f"‚ùå Erro ao inserir dados: {str(e)}")
            logger.error(f"Stack trace: {traceback.format_exc()}")
            logger.error(f"Dados que tentamos inserir: {data}")
            logger.error(f"Analytics: {analytics_data}")
            logger.error("="*50)
            raise

    def get_last_records(self, limit=5):
        """Obt√©m √∫ltimos registros"""
        try:
            if not self.conn or not self.conn.is_connected():
                self.connect_with_retry()

            query = """
                SELECT * FROM radar_dados
                ORDER BY timestamp DESC
                LIMIT %s
            """

            self.cursor.execute(query, (limit,))
            records = self.cursor.fetchall()

            # Converter datetime para string
            for record in records:
                if isinstance(record['timestamp'], datetime):
                    record['timestamp'] = record['timestamp'].strftime('%Y-%m-%d %H:%M:%S')

            return records
        except Exception as e:
            logger.error(f"Erro ao buscar registros: {str(e)}")
            return []

    def save_session_summary(self, session_data):
        """Salva o resumo da sess√£o no banco de dados"""
        try:
            logger.info("="*50)
            logger.info(f"Salvando resumo da sess√£o {session_data['session_id']}...")

            # Verificar conex√£o antes de inserir
            if not self.conn or not self.conn.is_connected():
                logger.info("Conex√£o n√£o dispon√≠vel, tentando reconectar...")
                self.connect_with_retry()

            # Preparar query
            query = """
                INSERT INTO radar_sessoes
                (session_id, start_time, end_time, duration, avg_heart_rate,
                 avg_breath_rate, avg_satisfaction, satisfaction_class, is_engaged, data_points)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                end_time = VALUES(end_time),
                duration = VALUES(duration),
                avg_heart_rate = VALUES(avg_heart_rate),
                avg_breath_rate = VALUES(avg_breath_rate),
                avg_satisfaction = VALUES(avg_satisfaction),
                satisfaction_class = VALUES(satisfaction_class),
                is_engaged = VALUES(is_engaged),
                data_points = VALUES(data_points)
            """

            # Determinar classifica√ß√£o de satisfa√ß√£o
            satisfaction_class = "NEUTRA"
            if session_data.get('avg_satisfaction') is not None:
                if session_data['avg_satisfaction'] >= 70:
                    satisfaction_class = "POSITIVA"
                elif session_data['avg_satisfaction'] <= 40:
                    satisfaction_class = "NEGATIVA"

            # Preparar par√¢metros
            start_time = session_data.get('start_time')
            end_time = session_data.get('end_time')

            # Converter para string se for datetime
            if isinstance(start_time, datetime):
                start_time = start_time.strftime('%Y-%m-%d %H:%M:%S')
            if isinstance(end_time, datetime):
                end_time = end_time.strftime('%Y-%m-%d %H:%M:%S')

            params = (
                session_data.get('session_id'),
                start_time,
                end_time,
                float(session_data.get('duration', 0)),
                float(session_data.get('avg_heart_rate', 0)) if session_data.get('avg_heart_rate') is not None else None,
                float(session_data.get('avg_breath_rate', 0)) if session_data.get('avg_breath_rate') is not None else None,
                float(session_data.get('avg_satisfaction', 0)) if session_data.get('avg_satisfaction') is not None else None,
                satisfaction_class,
                bool(session_data.get('is_engaged', False)),
                len(session_data.get('positions', []))
            )

            logger.info(f"Query SQL: {query}")
            logger.info(f"Par√¢metros: {params}")

            # Executar inser√ß√£o
            self.cursor.execute(query, params)
            self.conn.commit()

            logger.info(f"‚úÖ Resumo da sess√£o {session_data['session_id']} salvo com sucesso!")
            logger.info("="*50)
            return True

        except Exception as e:
            logger.error("="*50)
            logger.error(f"‚ùå Erro ao salvar resumo da sess√£o: {str(e)}")
            logger.error(f"Stack trace: {traceback.format_exc()}")
            logger.error(f"Dados da sess√£o: {session_data}")
            logger.error("="*50)
            raise

    def get_sessions(self, limit=10):
        """Obt√©m as sess√µes mais recentes"""
        try:
            if not self.conn or not self.conn.is_connected():
                self.connect_with_retry()

            query = """
                SELECT * FROM radar_sessoes
                ORDER BY end_time DESC
                LIMIT %s
            """

            self.cursor.execute(query, (limit,))
            sessions = self.cursor.fetchall()

            # Converter datetime para string
            for session in sessions:
                if isinstance(session['start_time'], datetime):
                    session['start_time'] = session['start_time'].strftime('%Y-%m-%d %H:%M:%S')
                if isinstance(session['end_time'], datetime):
                    session['end_time'] = session['end_time'].strftime('%Y-%m-%d %H:%M:%S')

            return sessions
        except Exception as e:
            logger.error(f"Erro ao buscar sess√µes: {str(e)}")
            logger.error(traceback.format_exc())
            return []

    def get_session_by_id(self, session_id):
        """Obt√©m uma sess√£o espec√≠fica pelo ID"""
        try:
            if not self.conn or not self.conn.is_connected():
                self.connect_with_retry()

            # Buscar resumo da sess√£o
            query_session = """
                SELECT * FROM radar_sessoes
                WHERE session_id = %s
            """

            self.cursor.execute(query_session, (session_id,))
            session = self.cursor.fetchone()

            if not session:
                return None

            # Converter datetime para string
            if isinstance(session['start_time'], datetime):
                session['start_time'] = session['start_time'].strftime('%Y-%m-%d %H:%M:%S')
            if isinstance(session['end_time'], datetime):
                session['end_time'] = session['end_time'].strftime('%Y-%m-%d %H:%M:%S')

            # Buscar pontos de dados da sess√£o
            query_points = """
                SELECT * FROM radar_dados
                WHERE session_id = %s
                ORDER BY timestamp ASC
            """

            self.cursor.execute(query_points, (session_id,))
            points = self.cursor.fetchall()

            # Converter datetime para string nos pontos
            for point in points:
                if isinstance(point['timestamp'], datetime):
                    point['timestamp'] = point['timestamp'].strftime('%Y-%m-%d %H:%M:%S')

            # Adicionar pontos √† sess√£o
            session['data_points'] = points

            return session
        except Exception as e:
            logger.error(f"Erro ao buscar sess√£o {session_id}: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    def insert_radar_data(self, data):
        """Insere dados do radar no banco"""
        try:
            logger.info("="*50)
            logger.info("Iniciando inser√ß√£o de dados no banco...")
            logger.info(f"Dados recebidos: {data}")

            # Verificar campos obrigat√≥rios
            required_fields = ['x_point', 'y_point', 'move_speed', 'heart_rate', 'breath_rate']
            for field in required_fields:
                if field not in data:
                    logger.error(f"Campo obrigat√≥rio ausente: {field}")
                    return False

            # Garantir valores padr√£o para campos que podem estar ausentes
            if 'satisfaction_score' not in data or data['satisfaction_score'] is None:
                data['satisfaction_score'] = 0.0

            if 'satisfaction_class' not in data or data['satisfaction_class'] is None:
                data['satisfaction_class'] = 'NEUTRA'

            if 'is_engaged' not in data or data['is_engaged'] is None:
                data['is_engaged'] = False

            if 'engagement_duration' not in data or data['engagement_duration'] is None:
                data['engagement_duration'] = 0

            if 'session_id' not in data or data['session_id'] is None:
                data['session_id'] = None

            if 'section_id' not in data or data['section_id'] is None:
                data['section_id'] = None

            if 'product_id' not in data or data['product_id'] is None:
                data['product_id'] = None

            if 'serial_number' not in data or data['serial_number'] is None:
                data['serial_number'] = 'RADAR_1'

            # Query de inser√ß√£o
            query = """
                INSERT INTO radar_dados
                (x_point, y_point, move_speed, heart_rate, breath_rate,
                satisfaction_score, satisfaction_class, is_engaged, engagement_duration,
                session_id, section_id, product_id, timestamp, serial_number)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """

            # Preparar par√¢metros
            params = (
                data.get('x_point'),
                data.get('y_point'),
                data.get('move_speed'),
                data.get('heart_rate'),
                data.get('breath_rate'),
                data.get('satisfaction_score', 0),
                data.get('satisfaction_class', 'NEUTRA'),
                data.get('is_engaged', False),
                data.get('engagement_duration', 0),
                data.get('session_id'),
                data.get('section_id'),
                data.get('product_id'),
                data.get('timestamp', datetime.now().strftime('%Y-%m-%d %H:%M:%S')),
                data.get('serial_number', 'RADAR_1')
            )

            logger.info(f"Query: {query}")
            logger.info(f"Par√¢metros: {params}")

            # Executar inser√ß√£o
            self.cursor.execute(query, params)
            self.conn.commit()

            logger.info("‚úÖ Dados inseridos com sucesso!")
            return True

        except Exception as e:
            logger.error(f"‚ùå Erro ao inserir dados: {str(e)}")
            logger.error(traceback.format_exc())
            return False

# Inst√¢ncia global do gerenciador de banco de dados
try:
    logger.info("Iniciando DatabaseManager...")
    db_manager = DatabaseManager()
    logger.info("‚úÖ DatabaseManager iniciado com sucesso!")
except Exception as e:
    logger.error(f"‚ùå Erro ao criar inst√¢ncia do DatabaseManager: {e}")
    logger.error(traceback.format_exc())
    db_manager = None

class AnalyticsManager:
    def __init__(self):
        # Constantes para engajamento
        self.ENGAGEMENT_TIME_THRESHOLD = 5  # segundos (voltando para 5 segundos)
        self.MOVEMENT_THRESHOLD = 20.0  # limite para considerar "parado" em cm/s
        self.ENGAGEMENT_MIN_DURATION = 5  # dura√ß√£o m√≠nima para considerar engajamento completo (segundos)

        # Constantes para satisfa√ß√£o
        self.RESP_RATE_NORMAL_MIN = 6
        self.RESP_RATE_NORMAL_MAX = 12
        self.RESP_RATE_ANXIETY = 20

        # Pesos para o c√°lculo de satisfa√ß√£o
        self.WEIGHT_HEART_RATE = 0.6  # Œ±
        self.WEIGHT_RESP_RATE = 0.4   # Œ≤

        # Rastreamento de engajamento
        self.engagement_start_time = None
        self.last_movement_time = None

    def calculate_engagement(self, records):
        """
        Calcula engajamento baseado no hist√≥rico de registros
        Retorna:
        - 0: N√£o detectado
        - 1: Engajamento inicial (< 5 segundos)
        - 2: Engajamento completo (>= 5 segundos)
        """
        if not records or len(records) < 2:
            logger.info("N√£o h√° registros suficientes para calcular engajamento")
            return 0, 0

        # Filtrar registros v√°lidos (com move_speed e timestamp)
        valid_records = []
        current_time = datetime.now()

        for record in records:
            if (record.get('move_speed') is not None and
                record.get('timestamp') is not None):
                try:
                    # Tentar converter o timestamp para datetime
                    record_time = datetime.strptime(record['timestamp'], '%Y-%m-%d %H:%M:%S')

                    # Verificar se o registro n√£o √© muito antigo (m√°ximo 10 segundos)
                    if (current_time - record_time).total_seconds() <= 10:
                        valid_records.append({
                            'move_speed': float(record['move_speed']),
                            'timestamp': record_time,
                            'x_point': float(record.get('x_point', 0)),
                            'y_point': float(record.get('y_point', 0))
                        })
                except (ValueError, TypeError) as e:
                    logger.error(f"Erro ao processar registro para engajamento: {str(e)}")
                    continue

        if len(valid_records) < 2:
            logger.info("N√£o h√° registros v√°lidos suficientes para calcular engajamento")
            return 0, 0

        # Ordenar registros por timestamp (mais recente primeiro)
        valid_records.sort(key=lambda x: x['timestamp'], reverse=True)

        # Verificar engajamento
        engagement_count = 0
        total_movement = 0
        last_position = None
        start_time = None

        for record in valid_records:
            current_time = record['timestamp']
            current_position = (record['x_point'], record['y_point'])
            move_speed = record['move_speed']

            # Calcular movimento total se houver posi√ß√£o anterior
            if last_position:
                movement = ((current_position[0] - last_position[0])**2 +
                          (current_position[1] - last_position[1])**2)**0.5
                total_movement += movement

            # Verificar crit√©rios de engajamento
            is_engaged = (
                move_speed <= self.MOVEMENT_THRESHOLD and  # Velocidade baixa
                (not last_position or  # Primeiro registro
                 total_movement <= 0.5)  # Movimento total menor que 50cm
            )

            if is_engaged:
                engagement_count += 1
                if start_time is None:
                    start_time = current_time
            else:
                # Reset se houver movimento significativo
                engagement_count = 0
                start_time = None
                total_movement = 0

            last_position = current_position

            # Verificar se temos engajamento suficiente
            if engagement_count >= 2:
                duration = (valid_records[0]['timestamp'] - start_time).total_seconds()

                if duration >= self.ENGAGEMENT_MIN_DURATION:
                    logger.info(f"Engajamento COMPLETO detectado! Dura√ß√£o: {duration:.1f}s")
                    return 2, duration
                else:
                    logger.info(f"Engajamento INICIAL detectado! Dura√ß√£o: {duration:.1f}s")
                    return 1, duration

        logger.info("Engajamento n√£o detectado")
        return 0, 0

    def calculate_satisfaction(self, heart_rate, breath_rate):
        """
        Calcula n√≠vel de satisfa√ß√£o baseado em batimentos card√≠acos e respira√ß√£o
        Retorna: score (0-100) e classifica√ß√£o ('POSITIVA', 'NEUTRA', 'NEGATIVA')
        """
        # Constantes para valida√ß√£o
        HEART_RATE_MIN = 60
        HEART_RATE_MAX = 100
        HEART_RATE_IDEAL_MIN = 65
        HEART_RATE_IDEAL_MAX = 75

        BREATH_RATE_MIN = 12
        BREATH_RATE_MAX = 20
        BREATH_RATE_IDEAL_MIN = 12
        BREATH_RATE_IDEAL_MAX = 16

        # Inicializar scores
        heart_score = 0
        resp_score = 0
        valid_data = False

        # Validar e calcular score de batimentos card√≠acos
        if heart_rate is not None and HEART_RATE_MIN <= heart_rate <= HEART_RATE_MAX:
            valid_data = True

            # C√°lculo mais granular para heart_rate
            if HEART_RATE_IDEAL_MIN <= heart_rate <= HEART_RATE_IDEAL_MAX:
                # Score m√°ximo para faixa ideal
                heart_score = 100
            elif heart_rate < HEART_RATE_IDEAL_MIN:
                # Penalidade progressiva abaixo do ideal
                heart_score = 100 - ((HEART_RATE_IDEAL_MIN - heart_rate) / 5) * 20
            else:  # heart_rate > HEART_RATE_IDEAL_MAX
                # Penalidade progressiva acima do ideal
                heart_score = 100 - ((heart_rate - HEART_RATE_IDEAL_MAX) / 5) * 20

            # Garantir que o score est√° entre 0 e 100
            heart_score = max(0, min(100, heart_score))

        # Validar e calcular score de respira√ß√£o
        if breath_rate is not None and BREATH_RATE_MIN <= breath_rate <= BREATH_RATE_MAX:
            valid_data = True

            # C√°lculo mais granular para breath_rate
            if BREATH_RATE_IDEAL_MIN <= breath_rate <= BREATH_RATE_IDEAL_MAX:
                # Score m√°ximo para faixa ideal
                resp_score = 100
            elif breath_rate > BREATH_RATE_IDEAL_MAX:
                # Penalidade progressiva acima do ideal
                resp_score = 100 - ((breath_rate - BREATH_RATE_IDEAL_MAX) / 2) * 25
            else:  # N√£o deve acontecer pois BREATH_RATE_IDEAL_MIN = BREATH_RATE_MIN
                resp_score = 100

            # Garantir que o score est√° entre 0 e 100
            resp_score = max(0, min(100, resp_score))

        # Se n√£o houver dados v√°lidos, retornar score neutro
        if not valid_data:
            logger.warning("Dados vitais inv√°lidos ou ausentes, retornando score neutro")
            return {
                'score': 50,
                'classification': 'NEUTRA',
                'heart_score': 50,
                'resp_score': 50,
                'is_valid': False
            }

        # Calcular score final com pesos
        final_score = (self.WEIGHT_HEART_RATE * heart_score +
                      self.WEIGHT_RESP_RATE * resp_score)

        # Classificar satisfa√ß√£o
        if final_score >= 70:
            classification = 'POSITIVA'
        elif final_score <= 40:
            classification = 'NEGATIVA'
        else:
            classification = 'NEUTRA'

        # Log detalhado do c√°lculo
        logger.info(f"C√°lculo de satisfa√ß√£o:")
        logger.info(f"  - Heart Rate: {heart_rate} bpm (score: {heart_score:.2f})")
        logger.info(f"  - Breath Rate: {breath_rate} rpm (score: {resp_score:.2f})")
        logger.info(f"  - Score Final: {final_score:.2f} ({classification})")

        return {
            'score': round(final_score, 2),
            'classification': classification,
            'heart_score': round(heart_score, 2),
            'resp_score': round(resp_score, 2),
            'is_valid': True
        }

# Inst√¢ncia global do analytics manager
analytics_manager = AnalyticsManager()

class UserSessionManager:
    def __init__(self):
        # Constantes para detec√ß√£o de entrada/sa√≠da
        self.PRESENCE_THRESHOLD = 2.0  # Dist√¢ncia m√°xima para considerar presen√ßa (metros)
        self.MOVEMENT_THRESHOLD = 50.0  # Movimento m√°ximo para considerar "parado" em cm/s
        self.ABSENCE_THRESHOLD = 3.0   # Dist√¢ncia m√≠nima para considerar aus√™ncia (metros)
        self.TIME_THRESHOLD = 2        # Tempo m√≠nimo (segundos) para considerar uma nova sess√£o

        # Estado atual
        self.current_session_id = None
        self.last_presence_time = None
        self.last_absence_time = None
        self.session_start_time = None
        self.session_data = {}
        self.last_position = (None, None)
        self.last_distance = None
        self.is_present = False
        self.consecutive_presence_count = 0  # Contador de presen√ßas consecutivas
        self.engagement_start_time = None  # Tempo de in√≠cio do engajamento

    def detect_session(self, data, timestamp=None):
        """
        Detecta se uma pessoa entrou ou saiu da √°rea da g√¥ndola
        Retorna: (session_id, event_type, session_data)
        event_type pode ser: 'start', 'update', 'end', None
        """
        if timestamp is None:
            try:
                # Tentar usar o timestamp dos dados
                if 'timestamp' in data and data['timestamp']:
                    timestamp = datetime.strptime(data['timestamp'], '%Y-%m-%d %H:%M:%S')
                else:
                    timestamp = datetime.now()
            except Exception as e:
                logger.error(f"Erro ao processar timestamp: {str(e)}")
                timestamp = datetime.now()

        # Extrair dados relevantes
        x_point = data.get('x_point')
        y_point = data.get('y_point')
        move_speed = data.get('move_speed', 999)
        is_engaged = data.get('is_engaged', 0)  # 0=n√£o, 1=inicial, 2=completo
        engagement_duration = data.get('engagement_duration', 0)

        # Calcular dist√¢ncia do centro (0,0)
        distance = np.sqrt(x_point**2 + y_point**2) if x_point is not None and y_point is not None else None

        # Log para debug
        logger.info(f"Detec√ß√£o de sess√£o: x={x_point}, y={y_point}, move_speed={move_speed} cm/s, dist√¢ncia={distance} m, timestamp={timestamp}")

        # Inicializar evento como None (sem evento)
        event_type = None

        # Verificar se h√° dados suficientes
        if distance is None:
            return self.current_session_id, None, None

        # Detectar presen√ßa/aus√™ncia
        was_present = self.is_present

        # Pessoa est√° presente se estiver pr√≥xima e com movimento limitado
        if distance <= self.PRESENCE_THRESHOLD:
            self.consecutive_presence_count += 1
            logger.info(f"Presen√ßa detectada! Contagem: {self.consecutive_presence_count}")

            # S√≥ consideramos presente ap√≥s 2 detec√ß√µes consecutivas
            if self.consecutive_presence_count >= 2:
                self.is_present = True
                self.last_presence_time = timestamp

                # Se n√£o havia sess√£o, iniciar uma nova
                if self.current_session_id is None:
                    self.current_session_id = str(uuid.uuid4())
                    self.session_start_time = timestamp
                    self.session_data = {
                        'session_id': self.current_session_id,
                        'start_time': timestamp,
                        'heart_rates': [],
                        'breath_rates': [],
                        'positions': [],
                        'move_speeds': [],
                        'satisfaction_scores': [],
                        'is_engaged': 0,  # 0=n√£o, 1=inicial, 2=completo
                        'engagement_duration': 0
                    }
                    event_type = 'start'
                    logger.info(f"üü¢ Nova sess√£o iniciada: {self.current_session_id}")
                else:
                    event_type = 'update'

                # Atualizar dados da sess√£o
                if data.get('heart_rate') is not None:
                    self.session_data['heart_rates'].append(data.get('heart_rate'))
                if data.get('breath_rate') is not None:
                    self.session_data['breath_rates'].append(data.get('breath_rate'))
                if data.get('satisfaction_score') is not None:
                    self.session_data['satisfaction_scores'].append(data.get('satisfaction_score'))

                self.session_data['positions'].append((x_point, y_point))
                self.session_data['move_speeds'].append(move_speed)

                # Verificar engajamento baseado no movimento
                if move_speed <= self.MOVEMENT_THRESHOLD:
                    logger.info(f"Movimento baixo detectado: {move_speed} cm/s <= {self.MOVEMENT_THRESHOLD} cm/s")

                    # Iniciar rastreamento de engajamento se ainda n√£o iniciado
                    if self.engagement_start_time is None:
                        self.engagement_start_time = timestamp
                        logger.info(f"In√≠cio do engajamento registrado: {timestamp}")
                        self.session_data['is_engaged'] = 1  # Engajamento inicial
                    else:
                        # Calcular dura√ß√£o do engajamento
                        engagement_duration = (timestamp - self.engagement_start_time).total_seconds()
                        self.session_data['engagement_duration'] = engagement_duration
                        logger.info(f"Dura√ß√£o do engajamento: {engagement_duration} segundos")

                        # Atualizar status de engajamento baseado na dura√ß√£o
                        if engagement_duration >= 5:  # 5 segundos para engajamento completo
                            self.session_data['is_engaged'] = 2  # Engajamento completo
                            logger.info(f"Engajamento COMPLETO detectado! Dura√ß√£o: {engagement_duration} segundos")
                        else:
                            self.session_data['is_engaged'] = 1  # Engajamento inicial
                            logger.info(f"Engajamento INICIAL mantido. Dura√ß√£o: {engagement_duration} segundos")
                else:
                    # Resetar rastreamento de engajamento se movimento for alto
                    if self.engagement_start_time is not None:
                        logger.info(f"Movimento alto detectado, resetando rastreamento de engajamento")
                        self.engagement_start_time = None

                # Usar o valor de engajamento calculado anteriormente se for maior
                if is_engaged > self.session_data['is_engaged']:
                    self.session_data['is_engaged'] = is_engaged
                    self.session_data['engagement_duration'] = engagement_duration
        else:
            self.consecutive_presence_count = 0

            # Resetar rastreamento de engajamento se pessoa sair da √°rea
            if self.engagement_start_time is not None:
                logger.info(f"Pessoa saiu da √°rea, resetando rastreamento de engajamento")
                self.engagement_start_time = None

            # Pessoa est√° ausente se estiver longe
            if distance >= self.ABSENCE_THRESHOLD:
                self.is_present = False
                self.last_absence_time = timestamp

                # Se havia uma sess√£o ativa, finaliz√°-la
                if was_present and self.current_session_id is not None:
                    # Calcular m√©tricas finais da sess√£o
                    session_duration = (timestamp - self.session_start_time).total_seconds()

                    # S√≥ considerar sess√£o v√°lida se durou mais que o tempo m√≠nimo
                    if session_duration >= self.TIME_THRESHOLD:
                        # Calcular m√©dias
                        avg_heart_rate = np.mean(self.session_data['heart_rates']) if self.session_data['heart_rates'] else None
                        avg_breath_rate = np.mean(self.session_data['breath_rates']) if self.session_data['breath_rates'] else None
                        avg_satisfaction = np.mean(self.session_data['satisfaction_scores']) if self.session_data['satisfaction_scores'] else None

                        # Adicionar m√©tricas finais
                        self.session_data['end_time'] = timestamp
                        self.session_data['duration'] = session_duration
                        self.session_data['avg_heart_rate'] = avg_heart_rate
                        self.session_data['avg_breath_rate'] = avg_breath_rate
                        self.session_data['avg_satisfaction'] = avg_satisfaction

                        event_type = 'end'
                        logger.info(f"üî¥ Sess√£o finalizada: {self.current_session_id}, dura√ß√£o: {session_duration:.2f}s")

                        # Guardar dados da sess√£o antes de resetar
                        session_data_copy = self.session_data.copy()

                        # Resetar sess√£o
                        self.current_session_id = None
                        self.session_start_time = None
                        self.session_data = {}
                        self.engagement_start_time = None

                        return session_data_copy['session_id'], event_type, session_data_copy

        # Atualizar √∫ltima posi√ß√£o e dist√¢ncia
        self.last_position = (x_point, y_point)
        self.last_distance = distance

        return self.current_session_id, event_type, self.session_data

# Inst√¢ncia global do gerenciador de sess√µes
user_session_manager = UserSessionManager()

class DataSmoother:
    def __init__(self, window_size=5):
        """
        Inicializa o suavizador de dados
        window_size: tamanho da janela para m√©dia m√≥vel
        """
        self.window_size = window_size
        self.heart_rate_history = []
        self.breath_rate_history = []

    def smooth_heart_rate(self, heart_rate):
        """Suaviza o valor de heart_rate usando m√©dia m√≥vel"""
        if heart_rate is None:
            return None

        self.heart_rate_history.append(heart_rate)
        if len(self.heart_rate_history) > self.window_size:
            self.heart_rate_history.pop(0)

        if len(self.heart_rate_history) < 2:
            return heart_rate

        return sum(self.heart_rate_history) / len(self.heart_rate_history)

    def smooth_breath_rate(self, breath_rate):
        """Suaviza o valor de breath_rate usando m√©dia m√≥vel"""
        if breath_rate is None:
            return None

        self.breath_rate_history.append(breath_rate)
        if len(self.breath_rate_history) > self.window_size:
            self.breath_rate_history.pop(0)

        if len(self.breath_rate_history) < 2:
            return breath_rate

        return sum(self.breath_rate_history) / len(self.breath_rate_history)

    def detect_anomalies(self, heart_rate, breath_rate):
        """
        Detecta anomalias nos dados vitais
        Retorna: (is_heart_anomaly, is_breath_anomaly)
        """
        if not self.heart_rate_history or not self.breath_rate_history:
            return False, False

        # Calcular m√©dias e desvios padr√£o
        heart_mean = sum(self.heart_rate_history) / len(self.heart_rate_history)
        breath_mean = sum(self.breath_rate_history) / len(self.breath_rate_history)

        heart_std = (sum((x - heart_mean) ** 2 for x in self.heart_rate_history) / len(self.heart_rate_history)) ** 0.5
        breath_std = (sum((x - breath_mean) ** 2 for x in self.breath_rate_history) / len(self.breath_rate_history)) ** 0.5

        # Definir limites para detec√ß√£o de anomalias (2 desvios padr√£o)
        heart_threshold = 2 * heart_std
        breath_threshold = 2 * breath_std

        # Verificar se os valores atuais s√£o anomalias
        is_heart_anomaly = heart_rate is not None and abs(heart_rate - heart_mean) > heart_threshold
        is_breath_anomaly = breath_rate is not None and abs(breath_rate - breath_mean) > breath_threshold

        return is_heart_anomaly, is_breath_anomaly

# Inst√¢ncia global do suavizador de dados
data_smoother = DataSmoother()

class AdaptiveSampler:
    def __init__(self):
        # Configura√ß√µes de amostragem
        self.HIGH_ACTIVITY_THRESHOLD = 30.0  # cm/s - acima disso √© considerado movimento significativo
        self.LOW_ACTIVITY_THRESHOLD = 10.0   # cm/s - abaixo disso √© considerado movimento m√≠nimo

        # Intervalos de amostragem em milissegundos
        self.HIGH_ACTIVITY_INTERVAL = 200    # 5 amostras por segundo para atividade alta
        self.MEDIUM_ACTIVITY_INTERVAL = 500  # 2 amostras por segundo para atividade m√©dia
        self.LOW_ACTIVITY_INTERVAL = 1000    # 1 amostra por segundo para atividade baixa
        self.IDLE_INTERVAL = 2000            # 1 amostra a cada 2 segundos para inatividade

        # Estado atual
        self.current_sampling_interval = self.MEDIUM_ACTIVITY_INTERVAL
        self.last_sample_time = None
        self.last_movement_speed = 0
        self.consecutive_idle_count = 0
        self.max_idle_count = 5  # N√∫mero m√°ximo de amostras consecutivas em estado de inatividade

    def should_sample(self, current_time, movement_speed):
        """
        Determina se devemos coletar uma amostra com base na atividade atual
        Retorna: (bool, int) - se deve amostrar e o pr√≥ximo intervalo recomendado
        """
        # Na primeira chamada, sempre amostrar
        if self.last_sample_time is None:
            self.last_sample_time = current_time
            return True, self.MEDIUM_ACTIVITY_INTERVAL

        # Calcular tempo decorrido desde a √∫ltima amostra
        elapsed_time = (current_time - self.last_sample_time).total_seconds() * 1000  # em ms

        # Determinar o intervalo de amostragem com base na velocidade de movimento
        if movement_speed > self.HIGH_ACTIVITY_THRESHOLD:
            # Atividade alta - amostragem frequente
            self.current_sampling_interval = self.HIGH_ACTIVITY_INTERVAL
            self.consecutive_idle_count = 0
            logger.info(f"Atividade alta detectada: {movement_speed:.1f} cm/s - amostragem a cada {self.current_sampling_interval} ms")
        elif movement_speed > self.LOW_ACTIVITY_THRESHOLD:
            # Atividade m√©dia - amostragem normal
            self.current_sampling_interval = self.MEDIUM_ACTIVITY_INTERVAL
            self.consecutive_idle_count = 0
            logger.info(f"Atividade m√©dia detectada: {movement_speed:.1f} cm/s - amostragem a cada {self.current_sampling_interval} ms")
        else:
            # Atividade baixa ou inatividade
            if movement_speed <= self.LOW_ACTIVITY_THRESHOLD / 2:
                # Incrementar contador de inatividade
                self.consecutive_idle_count += 1

                # Ap√≥s v√°rias amostras consecutivas de inatividade, reduzir ainda mais a frequ√™ncia
                if self.consecutive_idle_count >= self.max_idle_count:
                    self.current_sampling_interval = self.IDLE_INTERVAL
                    logger.info(f"Inatividade prolongada: {movement_speed:.1f} cm/s - amostragem a cada {self.current_sampling_interval} ms")
                else:
                    self.current_sampling_interval = self.LOW_ACTIVITY_INTERVAL
                    logger.info(f"Atividade baixa detectada: {movement_speed:.1f} cm/s - amostragem a cada {self.current_sampling_interval} ms")
            else:
                self.current_sampling_interval = self.LOW_ACTIVITY_INTERVAL
                logger.info(f"Atividade baixa detectada: {movement_speed:.1f} cm/s - amostragem a cada {self.current_sampling_interval} ms")

        # Verificar se o tempo decorrido √© maior que o intervalo atual
        should_sample = elapsed_time >= self.current_sampling_interval

        # Mudan√ßas abruptas na velocidade sempre devem ser amostradas
        if abs(movement_speed - self.last_movement_speed) > self.HIGH_ACTIVITY_THRESHOLD:
            logger.info(f"Mudan√ßa abrupta na velocidade detectada: {self.last_movement_speed:.1f} -> {movement_speed:.1f} cm/s")
            should_sample = True

        # Atualizar estado se for amostrar
        if should_sample:
            self.last_sample_time = current_time
            self.last_movement_speed = movement_speed

        return should_sample, self.current_sampling_interval

    def reset(self):
        """Reinicia o estado do amostrador"""
        self.last_sample_time = None
        self.last_movement_speed = 0
        self.consecutive_idle_count = 0
        self.current_sampling_interval = self.MEDIUM_ACTIVITY_INTERVAL

# Inst√¢ncia global do amostrador adaptativo
adaptive_sampler = AdaptiveSampler()

@app.route('/radar/data', methods=['POST'])
def receive_radar_data():
    """Endpoint para receber dados do radar"""
    try:
        logger.info("="*50)
        logger.info("üì° Requisi√ß√£o POST recebida em /radar/data")
        logger.info(f"Headers: {request.headers}")

        # Verificar Content-Type
        if not request.is_json:
            logger.error("‚ùå Content-Type n√£o √© application/json")
            return jsonify({
                "status": "error",
                "message": "Content-Type deve ser application/json"
            }), 400

        # Obter dados
        raw_data = request.get_json()
        logger.info(f"Dados recebidos: {raw_data}")

        # Verificar se h√° dados
        if not raw_data:
            logger.error("‚ùå Nenhum dado recebido")
            return jsonify({
                "status": "error",
                "message": "Nenhum dado recebido"
            }), 400

        # Converter dados
        converted_data, error = convert_radar_data(raw_data)
        if error:
            return jsonify({
                "status": "error",
                "message": error
            }), 400

        # Timestamp atual
        current_time = datetime.now()

        # Verificar se devemos processar esta amostra com base na atividade atual
        move_speed = converted_data.get('move_speed', 0)
        should_sample, next_interval = adaptive_sampler.should_sample(current_time, move_speed)

        if not should_sample:
            # Retornar resposta indicando que a amostra foi recebida mas n√£o processada
            return jsonify({
                "status": "success",
                "message": "Amostra ignorada pela pol√≠tica de amostragem adaptativa",
                "next_sample_interval_ms": next_interval
            })

        # Registrar que a amostra foi aceita
        logger.info(f"Amostra aceita para processamento. Pr√≥ximo intervalo: {next_interval} ms")

        # Suavizar dados vitais
        heart_rate = data_smoother.smooth_heart_rate(converted_data.get('heart_rate'))
        breath_rate = data_smoother.smooth_breath_rate(converted_data.get('breath_rate'))

        # Detectar anomalias
        is_heart_anomaly, is_breath_anomaly = data_smoother.detect_anomalies(heart_rate, breath_rate)

        if is_heart_anomaly:
            logger.warning(f"Anomalia detectada em heart_rate: {heart_rate}")
            heart_rate = None
        if is_breath_anomaly:
            logger.warning(f"Anomalia detectada em breath_rate: {breath_rate}")
            breath_rate = None

        # Atualizar dados convertidos com valores suavizados
        converted_data['heart_rate'] = heart_rate
        converted_data['breath_rate'] = breath_rate

        # Verificar se o banco est√° dispon√≠vel
        if not db_manager:
            logger.error("‚ùå Banco de dados n√£o dispon√≠vel")
            return jsonify({
                "status": "error",
                "message": "Banco de dados n√£o dispon√≠vel"
            }), 500

        # Adicionar timestamp atual
        converted_data['timestamp'] = current_time.strftime('%Y-%m-%d %H:%M:%S')

        # Identificar se√ß√£o e produto baseado na posi√ß√£o
        section = shelf_manager.get_section_at_position(
            converted_data['x_point'],
            converted_data['y_point'],
            db_manager
        )

        if section:
            converted_data['section_id'] = section['id']
            converted_data['product_id'] = section['product_id']
            logger.info(f"Pessoa detectada na se√ß√£o: {section['section_name']} (Produto: {section['product_name']})")
        else:
            # Ponto est√° fora de qualquer se√ß√£o, vamos ajustar para a se√ß√£o mais pr√≥xima
            logger.info(f"Ponto original ({converted_data['x_point']}, {converted_data['y_point']}) est√° fora de qualquer se√ß√£o. Ajustando...")

            # Buscar todas as se√ß√µes
            all_sections = shelf_manager.get_all_sections(db_manager)
            closest_section = None
            min_distance = float('inf')

            # Encontrar a se√ß√£o mais pr√≥xima
            for section_item in all_sections:
                # Calcular o centro da se√ß√£o
                section_center_x = (section_item['x_start'] + section_item['x_end']) / 2
                section_center_y = (section_item['y_start'] + section_item['y_end']) / 2

                # Calcular dist√¢ncia do ponto ao centro da se√ß√£o
                distance = ((converted_data['x_point'] - section_center_x) ** 2 +
                           (converted_data['y_point'] - section_center_y) ** 2) ** 0.5

                # Verificar se √© a se√ß√£o mais pr√≥xima
                if distance < min_distance:
                    min_distance = distance
                    closest_section = section_item

            if closest_section:
                # Associar √† se√ß√£o mais pr√≥xima sem alterar coordenadas
                logger.info(f"Associando √† se√ß√£o mais pr√≥xima: {closest_section['section_name']}")

                converted_data['section_id'] = closest_section['id']
                converted_data['product_id'] = closest_section['product_id']

                logger.info(f"Pessoa associada √† se√ß√£o: {closest_section['section_name']} (Produto: {closest_section['product_name']})")
            else:
                logger.warning("N√£o foi poss√≠vel encontrar uma se√ß√£o pr√≥xima")
                converted_data['section_id'] = None
                converted_data['product_id'] = None

        # Calcular sess√£o e engajamento
        session_id, event_type, session_data = user_session_manager.detect_session(converted_data)
        converted_data['session_id'] = session_id

        # Salvar resumo da sess√£o se for final de sess√£o
        if event_type == 'end' and session_data:
            try:
                db_manager.save_session_summary(session_data)
            except Exception as e:
                logger.error(f"Erro ao salvar resumo da sess√£o: {str(e)}")

        # Obter √∫ltimos 5 registros para calcular engajamento
        last_records = db_manager.get_last_records(5)

        # Calcular engajamento baseado nos √∫ltimos registros
        engagement_level, engagement_duration = analytics_manager.calculate_engagement(last_records)
        converted_data['is_engaged'] = bool(engagement_level)  # 0=n√£o, 1=inicial, 2=completo -> converte para boolean
        converted_data['engagement_duration'] = int(engagement_duration)

        # Calcular satisfa√ß√£o
        satisfaction_data = analytics_manager.calculate_satisfaction(
            converted_data.get('heart_rate'),
            converted_data.get('breath_rate')
        )

        converted_data['satisfaction_score'] = satisfaction_data['score']
        converted_data['satisfaction_class'] = satisfaction_data['classification']

        # Log dos dados calculados
        logger.info(f"Dados de engajamento: n√≠vel={engagement_level}, dura√ß√£o={engagement_duration}s")
        logger.info(f"Dados de satisfa√ß√£o: score={satisfaction_data['score']}, class={satisfaction_data['classification']}")

        # Inserir dados no banco
        success = db_manager.insert_radar_data(converted_data)

        if not success:
            logger.error("‚ùå Falha ao inserir dados no banco")
            return jsonify({
                "status": "error",
                "message": "Falha ao inserir dados no banco"
            }), 500

        return jsonify({
            "status": "success",
            "message": "Dados processados com sucesso",
            "data": converted_data,
            "next_sample_interval_ms": next_interval
        })

    except Exception as e:
        logger.error(f"‚ùå Erro ao processar dados: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro ao processar dados: {str(e)}"
        }), 500

@app.route('/radar/status', methods=['GET'])
def get_status():
    """Endpoint para verificar status"""
    try:
        status = {
            "server": "online",
            "database": "offline",
            "last_records": None,
            "connection_info": {}
        }

        try:
            # Verificar conex√£o
            if db_manager and db_manager.conn:
                is_connected = db_manager.conn.is_connected()
                status["connection_info"]["is_connected"] = is_connected

                if is_connected:
                    status["database"] = "online"
                    status["last_records"] = db_manager.get_last_records(5)

                    # Obter informa√ß√µes do servidor
                    try:
                        cursor = db_manager.conn.cursor(dictionary=True)
                        cursor.execute("SELECT VERSION() as version")
                        version = cursor.fetchone()
                        cursor.close()

                        if version:
                            status["connection_info"]["version"] = version["version"]
                    except Exception as e:
                        status["connection_info"]["version_error"] = str(e)
                else:
                    status["connection_info"]["connection_error"] = "Connection object exists but is not connected"
            else:
                status["connection_info"]["error"] = "Database manager or connection object is None"
        except Exception as e:
            status["connection_info"]["exception"] = str(e)

        return jsonify(status)
    except Exception as e:
        logger.error(f"Erro ao verificar status: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": str(e),
            "traceback": traceback.format_exc()
        }), 500

@app.route('/radar/sessions', methods=['GET'])
def get_sessions():
    """Endpoint para listar sess√µes"""
    try:
        if not db_manager:
            return jsonify({
                "status": "error",
                "message": "Banco de dados n√£o dispon√≠vel"
            }), 500

        # Obter limite da query string
        limit = request.args.get('limit', default=10, type=int)

        # Obter sess√µes
        sessions = db_manager.get_sessions(limit)

        return jsonify({
            "status": "success",
            "count": len(sessions),
            "sessions": sessions
        })
    except Exception as e:
        logger.error(f"Erro ao listar sess√µes: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro interno: {str(e)}"
        }), 500

@app.route('/radar/sessions/<session_id>', methods=['GET'])
def get_session(session_id):
    """Endpoint para obter detalhes de uma sess√£o"""
    try:
        if not db_manager:
            return jsonify({
                "status": "error",
                "message": "Banco de dados n√£o dispon√≠vel"
            }), 500

        # Obter sess√£o
        session = db_manager.get_session_by_id(session_id)

        if not session:
            return jsonify({
                "status": "error",
                "message": f"Sess√£o {session_id} n√£o encontrada"
            }), 404

        return jsonify({
            "status": "success",
            "session": session
        })
    except Exception as e:
        logger.error(f"Erro ao obter sess√£o {session_id}: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro interno: {str(e)}"
        }), 500

@app.route('/shelf/sections', methods=['GET'])
def get_sections():
    """Endpoint para listar todas as se√ß√µes"""
    try:
        if not db_manager:
            return jsonify({
                "status": "error",
                "message": "Banco de dados n√£o dispon√≠vel"
            }), 500

        sections = shelf_manager.get_all_sections(db_manager)

        return jsonify({
            "status": "success",
            "count": len(sections),
            "sections": sections
        })
    except Exception as e:
        logger.error(f"Erro ao listar se√ß√µes: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro interno: {str(e)}"
        }), 500

@app.route('/shelf/sections', methods=['POST'])
def add_section():
    """Endpoint para adicionar uma nova se√ß√£o"""
    try:
        if not request.is_json:
            return jsonify({
                "status": "error",
                "message": "Content-Type deve ser application/json"
            }), 400

        section_data = request.get_json()

        # Validar dados obrigat√≥rios
        required_fields = ['section_name', 'x_start', 'y_start', 'x_end', 'y_end', 'product_id', 'product_name']
        for field in required_fields:
            if field not in section_data:
                return jsonify({
                    "status": "error",
                    "message": f"Campo obrigat√≥rio n√£o fornecido: {field}"
                }), 400

        if not db_manager:
            return jsonify({
                "status": "error",
                "message": "Banco de dados n√£o dispon√≠vel"
            }), 500

        success = shelf_manager.add_section(section_data, db_manager)

        if success:
            return jsonify({
                "status": "success",
                "message": "Se√ß√£o adicionada com sucesso"
            })
        else:
            return jsonify({
                "status": "error",
                "message": "Erro ao adicionar se√ß√£o"
            }), 500

    except Exception as e:
        logger.error(f"Erro ao adicionar se√ß√£o: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro interno: {str(e)}"
        }), 500

@app.route('/shelf/sections/<int:section_id>', methods=['PUT'])
def update_section(section_id):
    """Endpoint para atualizar uma se√ß√£o existente"""
    try:
        if not request.is_json:
            return jsonify({
                "status": "error",
                "message": "Content-Type deve ser application/json"
            }), 400

        section_data = request.get_json()

        if not db_manager:
            return jsonify({
                "status": "error",
                "message": "Banco de dados n√£o dispon√≠vel"
            }), 500

        success = shelf_manager.update_section(section_id, section_data, db_manager)

        if success:
            return jsonify({
                "status": "success",
                "message": "Se√ß√£o atualizada com sucesso"
            })
        else:
            return jsonify({
                "status": "error",
                "message": "Erro ao atualizar se√ß√£o"
            }), 500

    except Exception as e:
        logger.error(f"Erro ao atualizar se√ß√£o: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro interno: {str(e)}"
        }), 500

@app.route('/radar/sampling/config', methods=['GET'])
def get_sampling_config():
    """Retorna a configura√ß√£o atual do amostrador adaptativo"""
    try:
        config = {
            "high_activity_threshold": adaptive_sampler.HIGH_ACTIVITY_THRESHOLD,
            "low_activity_threshold": adaptive_sampler.LOW_ACTIVITY_THRESHOLD,
            "high_activity_interval_ms": adaptive_sampler.HIGH_ACTIVITY_INTERVAL,
            "medium_activity_interval_ms": adaptive_sampler.MEDIUM_ACTIVITY_INTERVAL,
            "low_activity_interval_ms": adaptive_sampler.LOW_ACTIVITY_INTERVAL,
            "idle_interval_ms": adaptive_sampler.IDLE_INTERVAL,
            "max_idle_count": adaptive_sampler.max_idle_count,
            "current_sampling_interval_ms": adaptive_sampler.current_sampling_interval,
            "consecutive_idle_count": adaptive_sampler.consecutive_idle_count
        }

        return jsonify({
            "status": "success",
            "config": config
        })
    except Exception as e:
        logger.error(f"Erro ao obter configura√ß√£o de amostragem: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro interno: {str(e)}"
        }), 500

@app.route('/radar/sampling/config', methods=['POST'])
def update_sampling_config():
    """Atualiza a configura√ß√£o do amostrador adaptativo"""
    try:
        if not request.is_json:
            return jsonify({
                "status": "error",
                "message": "Content-Type deve ser application/json"
            }), 400

        config = request.get_json()

        # Atualizar par√¢metros
        if 'high_activity_threshold' in config:
            adaptive_sampler.HIGH_ACTIVITY_THRESHOLD = float(config['high_activity_threshold'])

        if 'low_activity_threshold' in config:
            adaptive_sampler.LOW_ACTIVITY_THRESHOLD = float(config['low_activity_threshold'])

        if 'high_activity_interval_ms' in config:
            adaptive_sampler.HIGH_ACTIVITY_INTERVAL = int(config['high_activity_interval_ms'])

        if 'medium_activity_interval_ms' in config:
            adaptive_sampler.MEDIUM_ACTIVITY_INTERVAL = int(config['medium_activity_interval_ms'])

        if 'low_activity_interval_ms' in config:
            adaptive_sampler.LOW_ACTIVITY_INTERVAL = int(config['low_activity_interval_ms'])

        if 'idle_interval_ms' in config:
            adaptive_sampler.IDLE_INTERVAL = int(config['idle_interval_ms'])

        if 'max_idle_count' in config:
            adaptive_sampler.max_idle_count = int(config['max_idle_count'])

        # Resetar o estado do amostrador ao aplicar novas configura√ß√µes
        adaptive_sampler.reset()

        logger.info(f"Configura√ß√£o de amostragem atualizada: {config}")

        return jsonify({
            "status": "success",
            "message": "Configura√ß√£o atualizada com sucesso",
            "config": {
                "high_activity_threshold": adaptive_sampler.HIGH_ACTIVITY_THRESHOLD,
                "low_activity_threshold": adaptive_sampler.LOW_ACTIVITY_THRESHOLD,
                "high_activity_interval_ms": adaptive_sampler.HIGH_ACTIVITY_INTERVAL,
                "medium_activity_interval_ms": adaptive_sampler.MEDIUM_ACTIVITY_INTERVAL,
                "low_activity_interval_ms": adaptive_sampler.LOW_ACTIVITY_INTERVAL,
                "idle_interval_ms": adaptive_sampler.IDLE_INTERVAL,
                "max_idle_count": adaptive_sampler.max_idle_count,
                "current_sampling_interval_ms": adaptive_sampler.current_sampling_interval
            }
        })
    except Exception as e:
        logger.error(f"Erro ao atualizar configura√ß√£o de amostragem: {str(e)}")
        logger.error(traceback.format_exc())
        return jsonify({
            "status": "error",
            "message": f"Erro interno: {str(e)}"
        }), 500

if __name__ == "__main__":
    port = int(os.getenv("PORT", 3000))
    host = os.getenv("HOST", "0.0.0.0")

    print("\n" + "="*50)
    print("üöÄ Servidor Radar iniciando...")
    print(f"üì° Endpoint dados: http://{host}:{port}/radar/data")
    print(f"‚ÑπÔ∏è  Endpoint status: http://{host}:{port}/radar/status")
    print(f"üë• Endpoint sess√µes: http://{host}:{port}/radar/sessions")
    print(f"üë§ Endpoint sess√£o espec√≠fica: http://{host}:{port}/radar/sessions/<session_id>")
    print(f"‚öôÔ∏è  Endpoint configura√ß√£o amostragem: http://{host}:{port}/radar/sampling/config")
    print(f"üõí Endpoint se√ß√µes da g√¥ndola: http://{host}:{port}/shelf/sections")
    print("‚ö° Use Ctrl+C para encerrar")
    print("="*50 + "\n")

    # Informa√ß√µes sobre a amostragem adaptativa
    print("üìä Sistema de Amostragem Adaptativa Ativado")
    print(f"   - Atividade alta (> {adaptive_sampler.HIGH_ACTIVITY_THRESHOLD} cm/s): {adaptive_sampler.HIGH_ACTIVITY_INTERVAL} ms")
    print(f"   - Atividade m√©dia: {adaptive_sampler.MEDIUM_ACTIVITY_INTERVAL} ms")
    print(f"   - Atividade baixa (< {adaptive_sampler.LOW_ACTIVITY_THRESHOLD} cm/s): {adaptive_sampler.LOW_ACTIVITY_INTERVAL} ms")
    print(f"   - Inatividade prolongada: {adaptive_sampler.IDLE_INTERVAL} ms")
    print("="*50 + "\n")

    app.run(host=host, port=port, debug=True)